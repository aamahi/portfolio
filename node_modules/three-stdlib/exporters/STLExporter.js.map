{"version":3,"file":"STLExporter.js","sources":["../../src/exporters/STLExporter.js"],"sourcesContent":["import { Vector3 } from 'three'\n\n/**\n * Usage:\n *  const exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  const data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nclass STLExporter {\n  parse(scene, options = {}) {\n    options = Object.assign(\n      {\n        binary: false,\n      },\n      options,\n    )\n\n    const binary = options.binary\n\n    //\n\n    const objects = []\n    let triangles = 0\n\n    scene.traverse(function (object) {\n      if (object.isMesh) {\n        const geometry = object.geometry\n\n        const index = geometry.index\n        const positionAttribute = geometry.getAttribute('position')\n\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3\n\n        objects.push({\n          object3d: object,\n          geometry: geometry,\n        })\n      }\n    })\n\n    let output\n    let offset = 80 // skip header\n\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4\n      const arrayBuffer = new ArrayBuffer(bufferLength)\n      output = new DataView(arrayBuffer)\n      output.setUint32(offset, triangles, true)\n      offset += 4\n    } else {\n      output = ''\n      output += 'solid exported\\n'\n    }\n\n    const vA = new Vector3()\n    const vB = new Vector3()\n    const vC = new Vector3()\n    const cb = new Vector3()\n    const ab = new Vector3()\n    const normal = new Vector3()\n\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d\n      const geometry = objects[i].geometry\n\n      const index = geometry.index\n      const positionAttribute = geometry.getAttribute('position')\n\n      if (index !== null) {\n        // indexed geometry\n\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0)\n          const b = index.getX(j + 1)\n          const c = index.getX(j + 2)\n\n          writeFace(a, b, c, positionAttribute, object)\n        }\n      } else {\n        // non-indexed geometry\n\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0\n          const b = j + 1\n          const c = j + 2\n\n          writeFace(a, b, c, positionAttribute, object)\n        }\n      }\n    }\n\n    if (binary === false) {\n      output += 'endsolid exported\\n'\n    }\n\n    return output\n\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a)\n      vB.fromBufferAttribute(positionAttribute, b)\n      vC.fromBufferAttribute(positionAttribute, c)\n\n      if (object.isSkinnedMesh === true) {\n        object.applyBoneTransform(a, vA)\n        object.applyBoneTransform(b, vB)\n        object.applyBoneTransform(c, vC)\n      }\n\n      vA.applyMatrix4(object.matrixWorld)\n      vB.applyMatrix4(object.matrixWorld)\n      vC.applyMatrix4(object.matrixWorld)\n\n      writeNormal(vA, vB, vC)\n\n      writeVertex(vA)\n      writeVertex(vB)\n      writeVertex(vC)\n\n      if (binary === true) {\n        output.setUint16(offset, 0, true)\n        offset += 2\n      } else {\n        output += '\\t\\tendloop\\n'\n        output += '\\tendfacet\\n'\n      }\n    }\n\n    function writeNormal(vA, vB, vC) {\n      cb.subVectors(vC, vB)\n      ab.subVectors(vA, vB)\n      cb.cross(ab).normalize()\n\n      normal.copy(cb).normalize()\n\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true)\n        offset += 4\n        output.setFloat32(offset, normal.y, true)\n        offset += 4\n        output.setFloat32(offset, normal.z, true)\n        offset += 4\n      } else {\n        output += '\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n'\n        output += '\\t\\touter loop\\n'\n      }\n    }\n\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true)\n        offset += 4\n        output.setFloat32(offset, vertex.y, true)\n        offset += 4\n        output.setFloat32(offset, vertex.z, true)\n        offset += 4\n      } else {\n        output += '\\t\\t\\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n'\n      }\n    }\n  }\n}\n\nexport { STLExporter }\n"],"names":["vA","vB","vC"],"mappings":"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"}